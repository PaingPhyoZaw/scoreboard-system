-- Create roles table if not exists
CREATE TABLE IF NOT EXISTS roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create users table if not exists
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT auth.uid(),
    full_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    role_id BIGINT REFERENCES roles(id) ON DELETE SET NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create score_categories table
CREATE TABLE IF NOT EXISTS score_categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    max_score INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create scores table
CREATE TABLE IF NOT EXISTS scores (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    score_date DATE NOT NULL,
    total_score DECIMAL(5,2) NOT NULL,
    target_score DECIMAL(5,2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create score_category_values table
CREATE TABLE IF NOT EXISTS score_category_values (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    score_id BIGINT REFERENCES scores(id) ON DELETE CASCADE,
    category_id BIGINT REFERENCES score_categories(id) ON DELETE CASCADE,
    score DECIMAL(5,2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Insert default roles
INSERT INTO roles (name) VALUES
('Engineer'),
('Service Admin'),
('Store'),
('Reception')
ON CONFLICT (name) DO NOTHING;

-- Insert default score categories
INSERT INTO score_categories (name, max_score) VALUES
('Technical Skills', 30),
('Communication', 20),
('Problem Solving', 25),
('Team Collaboration', 15),
('Initiative', 10)
ON CONFLICT DO NOTHING;

-- Drop existing functions if they exist
DROP FUNCTION IF EXISTS get_role_performance();
DROP FUNCTION IF EXISTS get_score_statistics();
DROP FUNCTION IF EXISTS get_all_engineers_stats();

-- Create function to calculate role performance
CREATE FUNCTION get_role_performance()
RETURNS TABLE (
    role VARCHAR(255),
    average_score DECIMAL(5,2),
    total_scores BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.name as role,
        COALESCE(AVG(s.total_score), 0) as average_score,
        COUNT(s.id) as total_scores
    FROM roles r
    LEFT JOIN users u ON u.role_id = r.id
    LEFT JOIN scores s ON s.user_id = u.id
    GROUP BY r.name;
END;
$$;

-- Create function to get score statistics
CREATE FUNCTION get_score_statistics()
RETURNS TABLE (
    total_scores BIGINT,
    average_score NUMERIC,
    highest_score NUMERIC,
    lowest_score NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::BIGINT as total_scores,
        ROUND(AVG(total_score)::NUMERIC, 2) as average_score,
        MAX(total_score)::NUMERIC as highest_score,
        MIN(total_score)::NUMERIC as lowest_score
    FROM scores
    WHERE score_date >= current_date - interval '30 days';
END;
$$;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Roles are viewable by authenticated users" ON roles;
DROP POLICY IF EXISTS "Users are viewable by authenticated users" ON users;
DROP POLICY IF EXISTS "Users can update their own record" ON users;
DROP POLICY IF EXISTS "Score categories are viewable by authenticated users" ON score_categories;
DROP POLICY IF EXISTS "Scores are viewable by authenticated users" ON scores;
DROP POLICY IF EXISTS "Users can insert their own scores" ON scores;
DROP POLICY IF EXISTS "Users can update their own scores" ON scores;
DROP POLICY IF EXISTS "Score category values are viewable by authenticated users" ON score_category_values;
DROP POLICY IF EXISTS "Users can insert their score category values" ON score_category_values;
DROP POLICY IF EXISTS "Users can update their score category values" ON score_category_values;

-- Add RLS policies
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE score_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE scores ENABLE ROW LEVEL SECURITY;
ALTER TABLE score_category_values ENABLE ROW LEVEL SECURITY;

-- RLS policies for roles
CREATE POLICY "Roles are viewable by authenticated users"
    ON roles FOR SELECT
    TO authenticated
    USING (true);

-- RLS policies for users
CREATE POLICY "Users are viewable by authenticated users"
    ON users FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Users can update their own record"
    ON users FOR UPDATE
    TO authenticated
    USING (auth.uid() = id);

-- RLS policies for score_categories
CREATE POLICY "Score categories are viewable by authenticated users"
    ON score_categories FOR SELECT
    TO authenticated
    USING (true);

-- RLS policies for scores
CREATE POLICY "Scores are viewable by authenticated users"
    ON scores FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Users can insert their own scores"
    ON scores FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own scores"
    ON scores FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id);

-- RLS policies for score_category_values
CREATE POLICY "Score category values are viewable by authenticated users"
    ON score_category_values FOR SELECT
    TO authenticated
    USING (true);

CREATE POLICY "Users can insert their score category values"
    ON score_category_values FOR INSERT
    TO authenticated
    WITH CHECK (EXISTS (
        SELECT 1 FROM scores s
        WHERE s.id = score_id
        AND s.user_id = auth.uid()
    ));

CREATE POLICY "Users can update their score category values"
    ON score_category_values FOR UPDATE
    TO authenticated
    USING (EXISTS (
        SELECT 1 FROM scores s
        WHERE s.id = score_id
        AND s.user_id = auth.uid()
    ));
